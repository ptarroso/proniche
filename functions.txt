library(terra)
library(geometry)
library(ks)

bioclim <- function(x, vars, nq=10) {
    vals <- extract(vars, x, ID=FALSE)
    qt <- seq(0, 0.5, length.out=nq)
    env_rect <- matrix(NA, nq, nlyr(vars)*2+1)
    env_rect[,1] <- qt
    colnames(env_rect) <- c("quantile", paste0(rep(names(vars), each=2), c("_min", "_max")))
    pred <- vars[[1]]*0
    for (i in 1:nq) {
        rng <- apply(vals, 2, quantile, probs=c(qt[i], 1-qt[i]))
        env_rect[i,-1] <- as.vector(rng)
        tmp <- pred * 0
		for (j in 1:nlyr(vars)) {
		    tmp <- tmp + (vars[[j]] >= rng[1,j] & vars[[j]] < rng[2,j])
		}
		pred <- pred + (tmp == nlyr(vars))
	}
	list(pred, env_rect)
}


convexHullModel <- function(x, vars) {
    vals <- as.matrix(extract(vars, x, ID=FALSE))
    pred <- vars[[1]]*0
    data <- as.matrix(vars)
    env_ch <- list()
    i <- 1
    while (nrow(vals) > 4) {
        ch <- geometry::convhulln(vals)
        values(pred) <- values(pred) + geometry::inhulln(ch, data)
        vals <- vals[-unique(ch),]
        env_ch[[i]] <- ch
        i <- i + 1       
    }
    list(pred, env_ch)
}

# Probably Only works with max of 6 variables
kernelModel <- function(x, vars) {
    vals <- extract(vars, x, ID=FALSE) 

    k <- ks::kde(vals, compute.cont=FALSE, approx.cont=TRUE)

    x <- as.data.frame(vars, na.rm=F)
    mask <- is.na(rowSums(x))
    pred <- vars[[1]]
    pred[!mask] <- predict(k, x=x[!mask,])
    list(pred, k)
}

gower <- function(x, train, rng = apply(train, 2, function(x) diff(range(x)))) {
    p <- ncol(train)
    for (k in 1:p) {
        d <- abs(x[k] - train[,k])/rng[k]
        if (k == 1)
            G <- d
        else
            G <- G + d
    }
    G/p
}

domainmodel <- function(x, vars) {
    vals <- extract(vars, x, ID=FALSE) 
    data <- as.data.frame(vars, na.rm=F)
    D <- rep(NA, nrow(data))
    mask <- !is.na(rowSums(data))
    rng <-  unlist(apply(vals, 2, function(d) diff(range(d))))
    for (i in which(mask)) {
        G <- gower(unlist(data[i,]), vals, rng)
        G[which(G>1)] <- 1
        D[i] <- max(1-G, na.rm=T)
       
    }
    pred <- vars[[1]] * NA
    values(pred) <- D
    pred
}

# mahalanobis distance
mah.dist <- function(x, u, sigma) {
    sqrt(t(x-u)%*%solve(sigma)%*%(x-u))
}

mahalanobisModel <- function(x, vars) {
    vals <- extract(vars, x, ID=FALSE) 
    data <- as.data.frame(vars, na.rm=F)
    M <- rep(NA, nrow(data))
    mask <- !is.na(rowSums(data))
    u <- colMeans(vals)
    sigma <- cov(vals) # Need always a few points to estimate covaraince
    for (i in which(mask)) {
        M[i] <- mah.dist(unlist(data[i,]), u, sigma)
    }
    pred <- vars[[1]] * NA
    values(pred) <- M
    pred
}

PI <- vect("GIS/world_borders_PI.shp")
tmp <- rast("GIS/wc2.0_bio_5m_01.tif")
prc <- rast("GIS/wc2.0_bio_5m_12.tif")
vars <- c(tmp, prc)
chilus <- read.table("GIS/chilus.csv", sep=";", header=TRUE)

bc <- bioclim(chilus, vars)
plot(bc[[1]])






